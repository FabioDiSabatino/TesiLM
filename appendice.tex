\appendix
\chapter{Quaternioni e rotazioni nello spazio}
\label{app:rotazioni}


\chapter{Filtro di Kalman}
\label{app:kalman}


\chapter{Script}

\section{Testing}
\subsection{Script per la stima del tempo di lettura di dati provenienti dall'IMU }
\label{app:stimai2c}
Di seguito si riporta il codice utilizzato per stimare il tempo di lettura di dati provenienti dall'unit√† di misura inerziale utilizzando un canale I2C in fast-mode.\\
\noindent\rule{14.1cm}{0.4pt}
\begin{lstlisting}[language=C]
//Test I2C speed
while(1){
if(id<1000){

	if(!I2C_ReadData(LSM9DS1_I2C_BADD,LSM9DS1_WHO_AM_I,&result,1)){
		if( result == LSM9DS1_WHO_AM_I_VALUE)
				id++;
	}
	else
	{
		lost++;
	}
	
 	if(id==1000){
		t1=HAL_GetTick()-t0;
		HAL_Delay(2);
		snprintf(data, 10, "%Lu",t1);
		CDC_Transmit_FS((uint8_t *)data,strlen(data));
	}
}



\end{lstlisting}


\subsection{Script per la stima del tempo di trasmissione di dati al modulo App}
\label{app:stimausb}
Di seguito si riporta il codice utilizzato per stimare il tempo di trasmissione sul canale USB utilizzato nella classe CDC.\\
\noindent\rule{14.1cm}{0.4pt}

\begin{lstlisting}[language=C]
 //Test usb CDC speed
while(1)
{
	snprintf(data, 10, "%d|%d\n",id,lost);
	if(id<1000){
		if(CDC_Transmit_FS((uint8_t *)data,strlen(data))== USBD_OK)
		{
			id++;
		}
		else{
			lost++;
		}

	if(id==1000){
		t1=HAL_GetTick()-t0;
		snprintf(data, 10, "%Lu\n",t1);
		CDC_Transmit_FS((uint8_t *)data,strlen(data));
	}
	
}



\end{lstlisting}



