\appendix


\chapter{Script}

\section{Operativi}
\subsection{Script per la lettura dei valori misurati da Accelerometro e Giroscopio tramite I2C}
\label{scriptXLGRead}
Di seguito si riporta il codice utilizzato per leggere i dati misurati dall'accelerometro e dal giroscpio utilizzando un canale I2C in fast-mode.\\
\noindent\rule{14.1cm}{0.4pt}
\begin{lstlisting}[language=C]
LSM9DS1_XLG_READ LSM9DS1_Read_XLG(MFX_input_t *data_in, int samples)
{
	int16_t pData[6]={0,0,0,0,0,0};
	int16_t data=0;
	int8_t regadd;
	int i,j,k;
	float divisor=1000;
	float sensitivityXL= (float) LSM9DS1_get_Sens_XL();
	float sensitivityG= (float) LSM9DS1_get_Sens_G();

	uint8_t hi;
	uint8_t lo;

	/* Read output registers from LSM9DS1_OUT_X_L_G to LSM9DS1_OUT_Z_XL. */
	for (i = 0; i < samples; i++ )
	{
		regadd=LSM9DS1_OUT_X_L_G;

		//read Gyroscope output
		for (j = 0; j < 3; j++ )
		{
			if( !I2C_ReadData(LSM9DS1_I2C_BADD, regadd, &lo,1))
			{
				return 0;
			}
			regadd++;
			if( !I2C_ReadData(LSM9DS1_I2C_BADD,regadd, &hi,1))
			{
				return 0 ;
			}
			regadd++;

			data = ((uint16_t)hi << 8) | (uint16_t)lo;
			pData[j]=data;

		}
		/* Format the data. */
		data_in->gyro[0] =  (pData[0] * sensitivityG )/divisor;
		data_in->gyro[1] =  (pData[1] * sensitivityG )/divisor;
		data_in->gyro[2] = ((pData[2] * sensitivityG )/divisor);

		regadd=LSM9DS1_OUT_X_L_XL;
		//read Accelerometer output
		for (j = 3; j < 6; j++ )
		{
			if( !I2C_ReadData(LSM9DS1_I2C_BADD, regadd, &lo,1))
			{
				return 0;
			}
			regadd++;
			if( !I2C_ReadData(LSM9DS1_I2C_BADD,regadd, &hi,1))
			{
				return 0 ;
			}
			regadd++;

			data = ((uint16_t)hi << 8) | (uint16_t)lo;
			pData[j]=data;

		}
		/* Format the data. */
		data_in->acc[0] =  (pData[3] * sensitivityXL)/divisor;
		data_in->acc[1] =  (pData[4] * sensitivityXL)/divisor;
		data_in->acc[2] = (pData[5] * sensitivityXL)/divisor;
	}
	return 1;
}



\end{lstlisting}

\section{Testing}
\subsection{Script per la stima del tempo di lettura di dati provenienti dall'IMU }
\label{app:stimai2c}
Di seguito si riporta il codice utilizzato per stimare il tempo di lettura di dati provenienti dall'unit√† di misura inerziale utilizzando un canale I2C in fast-mode.\\
\noindent\rule{14.1cm}{0.4pt}
\begin{lstlisting}[language=C]
//Test I2C speed
while(1){
if(id<1000){

	if(!I2C_ReadData(LSM9DS1_I2C_BADD,LSM9DS1_WHO_AM_I,&result,1)){
		if( result == LSM9DS1_WHO_AM_I_VALUE)
				id++;
	}
	else
	{
		lost++;
	}
	
 	if(id==1000){
		t1=HAL_GetTick()-t0;
		HAL_Delay(2);
		snprintf(data, 10, "%Lu",t1);
		CDC_Transmit_FS((uint8_t *)data,strlen(data));
	}
}



\end{lstlisting}


\subsection{Script per la stima del tempo di trasmissione di dati al modulo App}
\label{app:stimausb}
Di seguito si riporta il codice utilizzato per stimare il tempo di trasmissione sul canale USB utilizzato nella classe CDC.\\
\noindent\rule{14.1cm}{0.4pt}

\begin{lstlisting}[language=C]
 //Test usb CDC speed
while(1)
{
	snprintf(data, 10, "%d|%d\n",id,lost);
	if(id<1000){
		if(CDC_Transmit_FS((uint8_t *)data,strlen(data))== USBD_OK)
		{
			id++;
		}
		else{
			lost++;
		}

	if(id==1000){
		t1=HAL_GetTick()-t0;
		snprintf(data, 10, "%Lu\n",t1);
		CDC_Transmit_FS((uint8_t *)data,strlen(data));
	}
	
}



\end{lstlisting}


\chapter{Filtro di Kalman}


\label{appendixKalman}
